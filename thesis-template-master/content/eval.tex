\chapter{Design und Implementation}\label{ch:eval}

Dieses Kapitel beschreibt die Implementation des Algorithmus und erklärt Entscheidungen, die im
Laufe der Implementation getroffen wurden.

\section{Design}

Basierend auf den Erkenntnissen aus Chapter 1 und 2 kann nun der Algorithmus implementiert 
werden, welcher im Paper ... beschrieben wird. Die Implementation zielt darauf unabhängig vom 
darunterliegenden Smart Home System anwendbar zu sein. Das Ziel ist es theoretisch ein zukunftsfähiges Tool 
zu entwickeln, welches allen Smart Home Nutzern ermöglicht sich vor Abhhängigkeits zerstörenden Updates zu
schützen.Oft werden Geräte automatisch über eine aktive Internetverbindung geupdatet oder auch durch andere
Geräte wie zum Beispiel einem Hub. Idealerweise sollten Nutzer jedoch vor jedem Update gefragt werden, ob sie dieses
installieren wollen. Es wäre also von Vorteil, wenn es für den Nutzer eine Übersicht über alle möglichen Updates geben würde,
in der er sich dann für passende Updates entscheiden kann. Für solch eine Übersicht bietet sich ein Smartphone an






Nun benötigt man noch eine Möglichkeit die Informationen über die Services und Updates eines Geräts leicht abfragen zu können.
Eine solche Abfrage müsste in der Realität für jedes Gerät individuell angepasst werden. Dies ist jedoch nicht umsetzbar,
weswegen es nötig ist einen einheitlichen Weg zu finden. Geräte besitzen üblicherweise Metadaten, welche Informationen über 
Firmware Version, Größe usw. enthalten. Diesen Metadaten könnte man zusätzlich Informationen über Services und Updates 
hinzufügen, sodass man einen schnellen Überblick über alle Geräte innerhalb eines Netzwerks erhalten kann.

Der entwickelte Algorithmus wird nicht an realen Smart Home Systemen getestet, weswegen sich diese Frage 
zunächst erübrigt. Es bieten sich zwei Möglichkeiten an den Algorithmus zu testen. Eine Möglichkeit ist eine statische Liste, welche man 
man manuell mit Geräten und deren Updates füllt, oder ein Generator, welcher abhängig von Parametern ein "künstliches" Smart Home
System kreiert. Parameter wären dann zum Beispiel die Anzahl der Geräte oder die Anzahl der Updates, die ein einzelnes Gerät besitzt.
Der Generator bietet sich mehr an, da der Algorithmus nicht nur getestet, sondern auch evaluiert werden soll.
Die Evaluation kann dann an unterschiedlich komplexen Smart Home Systemen durchgeführt werden, indem man die Parameter 
dementsprechend verändert. Parameter wären zum Beispiel die Anzahl der Geräte, die Anzahl der Updates die ein Gerät besitzt oder 
auch die Anzahl der Services. 





Daher sollte der Algorithmus möglichst
unabhängig vom darunterliegenden Smart Home System sein. Zu diesem Zwecke war es zunächst 
notwendig einen Generator zu entwickeln, auf welchem dann der später implementierte Algorithmus 
getestet werden kann.  Der Generator funktioniert so, dass er Geräte erzeugt, welche
in Form von Objekten gespeichert werden. Diese Geräte enthalten Informationen über alle ihre Dienstleistungen 
und alle möglichen Updates. Bei realen Geräten müssten diese Informationen in den Metadaten
gespeichert werden, um sie leicht abfragen zu können. Dies ist eine Voraussetzung für den Algorithmus, ohne
die es nicht möglich wäre die Implementation Systemunabhängig zu gestalten. Da Metadaten bei den meisten
Geräten bereits existieren, sollte es für die Entwickler dieser Geräte kein großes Problem darstellen die Metadaten
um diese Informationen zu ergänzen. 
Nachdem die Geräte erstellt wurden, kreiert der Generator künstliche Abhängigkeiten zwischen diesen Geräten, um 
so ein Netzwerk zu simulieren. Eine Abhängigkeit sieht so aus, dass ein Gerät Zugriff auf die Dienstleistungen eines
anderen Geräts benötigt. Solch ein simples Netzwerk reicht im Rahmen dieser Arbeit völlig aus, da für den
Algorithmus die Struktur des Smart Homes später völlig egal sein wird. Lediglich die Abhängigkeiten zwischen den 
einzelnen Geräten sind interessant. Außerdem ist es ist möglich in Abhängigkeit von verschiedenen Parametern die Komplexität
der erzeugten Smart Home Netzwerke zu variieren. So können die Anzahl der Geräte, die Anzahl der möglichen 
Updates pro Gerät, die Anzahl der Dienstleistungen pro Gerät oder auch die Anzahl der Abhängigkeiten zwischen den
Geräten variiert werden. Dies ermöglich den später implementierten an Algorithmus an verschiedenen Systemen zu 
evaluieren, um so ein gutes Fazit über Effiziens und Lauftzeit treffen zu können.  

Der Algorithmus selbst funktioniert folgendermaßen. Im ersten Schritt







The evaluation usually consists of three main steps:
first it defines the goals intended to be achieved by the software in detail;
next is a description of the methodology
used to measure the satisfaction of the software in relation to these goals;
finally, the measurements are depicted and assessed.

