\chapter{Related Work}\label{ch:related_work}


In diesem Kapitel wird das Thema Langlebigkeit im Bereich Software Engineering thematisiert. Infolgedessen werden
Smart Home Systeme unter dem Aspekt der Langlebigkeit genauer beleuchtet und  das Thema Dependency Management aufgegriffen, wobei bereits 
bestehende Ansätze/Lösungen diesbezüglich genauer betrachtet. Zusätzlich wird der aktuelle Stand des Dependency Managements im 
Bereich Smart Home untersucht.


\section{Smart Homes}
Es existieren viele verschiedene Anbieter mit verschiedenen zugrundle liegenden Architekturen für Smart Home Systeme .
Im Rahmen dieser Arbeit ist es jedoch nicht notwendig die verschiedenen Smart Home Architekturen genauer zu beleuchten. 
Dennoch schadet es nicht sich einen groben Überblick über die aktuellen Technologien zu verschaffen. Grob kann man die
verschiedenen Architekturen darin unterscheiden, ob sie eine Verknüpfung zu einer Cloud besitzen. Cloud gebundene
Architekturen bieten dem Nutzer meist eine einfachere Installation und Wartung, indem zum 
Beispiel Updates automatisch installiert werden.Gleichzeitig bringen sie aber auch potenzielle Gefahren mit sich. Die 
Abhängigkeit von einer Cloud macht Smart Home Systeme sehr verwundbar. Wird ein externer Service, wie zum
Beispiel die Cloud abgeschaltet, kann es zu starken Ausfällen im System führen. [5](Towards Longevity of Smart Homes).
Des Weiteren sind Geräte, die mit einer Cloud verbunden sind anfälliger gegenüber Angriffen von Außenstehenden, die sich 
Zugriff auf das System beschaffen wollen.
Nicht Cloud-gebundene Architekturen haben diese Nachteile nicht. Es ist jedoch meist schwieriger eine solche Architektur aufzubauen, 
da sie zum Beispiel, wie im Falle von OpenHab[6], viel manuelle Konfiguration benötigt. Zusätzlich bieten nicht Cloud-gebundene Architekturen
mehr Sicherheit, da sie keine starken Abhängigkeiten zu anderen Dienstleistern benötigen.
Natürlich könnte man Smart Home Systeme noch weiter spezifizieren, indem man einzelne Komponenten genauer beleuchet und 
verschiedene Smart Home Anbieter miteinander vergleicht, jedoch ist dies, wie bereits erwähnt, im Rahmen dieser 
Arbeit nicht notwendig. Der zu entwickelnde Algorithmus soll nämlich später theoretisch Platform- und Architekturunabhängig anwendbar sein.
Zu diesem Zweck werden im Folgenden einige Aspekte bezüglich Smart Homes definiert und vorausgesetzt. [Paper 12]

Im Rahmen dieser Arbeit soll die ausgewählte Architektur keinen Einfluss auf den zu implementierenden Algorithmus haben.
Daher wird die für den Algorithmus genutzte Architektur möglichst simpel gehalten. 
\linebreak
\textit{A smart home has a set of devices that are connected through
a platform. Each device has a certain software version and
a set of available updates. Each software version has a set
of available predefined services. Devices can use services of
other devices which creates dependencies. An update configuration
is one of the finite states of the nondeterministic
finite automaton (NFA) that can be constructed by using the
configurations as states and connecting them using individual
updates as transitions.}[4]
Welche Geräte solch eine Architektur beinhaltet oder durch was für eine Platform genau die Geräte miteinander verbunden sind
spielt zunächst keine Rolle. Wichtig sind nur die genannten Komponenten:
\begin{itemize}
\item Device (Gerät): Geräte sind die Komponenten, die die eigentliche Funktionalität anbieten. Sie besitzen eine aktuelle Firmware
Version mit entsprechenden Diensleistungen, potenzielle Updates und Abhängigkeiten zu anderen Geräten, indem sie auf deren
Dienstleistungen zugreift.
\item Firmware Version: Die Firmware Version gibt an, welche Dienstleistungen ein Gerät anbietet 
\item Service (Dienstleistungen): Eine Dienstleistung ist eine Funktionalität, die ein Gerät anbietet. Zum Beispiel bietet ein Thermostat
die Dienstleistungen "Temperatur messen" an.
\item Update: Eine Aktualisierung der Firmware eines Geräts. Durch ein Update können sich angebotenen Diensleistungen eines Geräts ändern.
\item Platform: Die Komponente, die alle Geräte miteinander vernetzt.
\item Dependency (Abhängigkeiten): Eine Abhängigkeit zwischen zwei Geräten besteht, wenn ein Gerät Zugriff auf die Dienstleistungen eines
anderen Geräts benötigt.
\item Update Configuration: Eine Updatekonfiguration beschreibt die aktuelle Firmware aller Geräte in einem System. Sie bietet also eine Art 
Übersicht aller Geräte. 
\end{itemize}

\begin{figure}[!ht]
\hspace*{-2,5cm}                                                           
\includegraphics{"System Model"}
  \caption{Caption}
  \label{fig:Prob1:MEA}
\end{figure}


\newpage
\subsection{Prescriptive vs Descriptive Standards}
Für die Kommunikation der Geräte untereinander existieren viele Kommunikationsprotokolle wie zum Beispiel Bluetooth,
Wi-Fi oder auch XMPP. Diese sind bereits im großen Umfang in Verwendung und stark erforscht, weshalb es keiner weiteren
Untersuchung dieser Protokolle im Rahmend dieser Arbeit bedarf.
Kommunikation allein recht jedoch nicht, die Geräte müssen nicht nur untereinander kommunizieren, sondern sie müssen sich auch 
verstehen. Dafür ist ein Standard notwendig, welcher die Funktionen/Dienstleistungen der Geräte beschreibt.
Die zwei führenden Ansätze im Bereich IoT/Smart Homes sind desktiptive und preskriptive Standards. [4]
Preskriptive Standards definieren alle Geräte- und Dienstleistungstypen, die in einem Smart Home System vorkommen können.
Durch diese "Vordefinition" kann es zu keinen Redundanzen kommen, was zum Beispiel bedeuten würde, dass zwei verschiedene
Anbieter für den gleichen Gerätetyp zwei verschiedene Definitionen verwenden. Ein preskriptiver Standard ermöglich damit eine 
einfache Kommunikation zwischen den Geräten. 
Ein deskriptiver Standard hingegen erlaubt es dem Verkäufer seine Geräte und die dazugehörigen Dienstleistungen selbst zu definieren.
Für Verkäufer bedeutet dies eine einfachere Entwicklung von Geräten und Dienstleistungen, sobald jedoch Geräte von verschiedenen 
Anbietern miteinander kommunzieren wollen, kann es aufgrund von Redundanzen nötig sein, dass eine Art Übersetzung zwischen den 
Geräten stattfindet.
In der Realität bieten sich hybride Standards vermutlich am meisten an, da sowohl deskriptive als auch preskriptive Standards Vor- und
Nachteile besitzen.   


\subsection{Update Planing}
Oft werden Smart Home Geräte automatisch über eine aktive Internetverbindung geupdatet oder auch durch andere
Geräte wie zum Beispiel einem Hub. Dies bietet dem Nutzer mehr Komfort, da kein manueller Aufwand für Updates ensteht.
Solches "Remote Updating" sollte aber eigentlich vermieden werden, da dadurch zum Beispiel schädliche Software installiert werden
kann. Außerdem müsste der externe Diensleister, der das Updaten der Geräte übernimmt, viele Informationen über das System sammeln,
um so ideale Updatekonfigurationen zu finden. Das Preisgeben aller Informationen sollte nicht leichtsinnig getan werden, da es viele
potenzielle Gefahren birgt. Allein die Information, wann eine automatisierte Heizung anfängt zu heizen kann potenziellen Kriminellen Informationen
darüber geben, wann jemand zu Hause ist oder wann ein Haus leer steht. 
Idealerweise sollten Nutzer daher das Updaten lokal selbst übernhemen. Dies bedeutet selbstverständlich mehr manuelle Konfiguration,
vor jedem Update, da der Nutzer gefragt werden sollte, ob er ein installieren möchte. Diese Frage kann ein Nutzer jedoch ohne weitere Informationen
gar nicht plausibel entscheiden. Es wäre also von Vorteil, wenn es für den Nutzer
eine Übersicht über alle möglichen Updates geben würde, in der er sich dann für passende Updates entscheiden kann. 
Für einen solchen Zweck bietet sich Smartphone als zentrales Gerät an um eine Übersicht über alle im 
System vorkommenden Geräte zu erstellen.
Dazu benötigt man eine Möglichkeit die Informationen über die Services und Updates eines Geräts leicht abfragen zu können.
Eine solche Abfrage müsste in der Realität für jedes Gerät individuell angepasst werden. Dies ist jedoch nicht umsetzbar,
weswegen es nötig ist einen einheitlichen Weg zu finden. Geräte besitzen üblicherweise Metadaten, welche Informationen über 
Software Version, Speicherbedarf usw. enthalten. Diesen Metadaten könnte man zusätzlich Informationen über Dienstleistungen und Updates 
hinzufügen, sodass man einen schnellen Überblick über alle Geräte innerhalb eines Netzwerks erhalten kann.

\section{Langlebigkeit}
Im Bereich Software Engineering ist Langlebigkeit ein bekanntes Problem. Es wurden bereits Untersuchungen über die durchschnittliche 
Lebensdauer von Software durchgeführt. Für kleine Projekte im Bereich von unter 100.000 Zeilen Code wird eine Lebensdauer von circa 
6-8 Jahren erwartet. Dabei ist zu beobachten, dass mit steigender Größe eines Projekts die erwartete Lebensdauer im Durchschnitt
ebenfalls steigt. Dies hängt vermutlich mit den hohen Kosten zusammen, die für größere Projekte aufkommen, weswegen man daran
interessiert ist lange einen Nutzen von der Software zu haben. Gründe für das Altern von Software sind vielseitig, zum Beispiel kann
die Wartung von Software einfach zu teuer werden, so dass es sich lohnt neue Software zu entwickeln oder die Entwicklungsumgebung wird
nicht mehr unterstützt und es lohnt sich nicht die Software zu portieren. Andere Gründe können Sicherheitslücken oder auch fehlerhafte 
Updates sein. Die German Research Foundation hat ein Projekt namens Design for Future ins Leben gerufen, um das Problem der Langlebigkeit
von Software zu untersuchen. Ziel ist es fundamentale neue Ansätze im Bereich langlebiger Software zu finden, um Probleme mit Legacy-Software
oder der Adaption von Software auf neue Plattformen zu lösen und eine kontinuierliche Weiterentwicklung von Software Systemen gewährleisten 
zu können [6].
Im Bereich Smart Home existieren keine solche Programme. Das Problem der Langlebigkeit wird in diesem Kontext unterschätzt oder einfach ignoriert.
Aufgrund der Komplexität der Systeme besitzen sie viele Schwachstellen die zu einem frühzeitigen Ausfall des Systems führen können. Dazu gehören:

\begin{figure}[h]
\centering
\includegraphics{"Threats"}
\caption{Caption}
\label{fig:Prob1:MEA}
\end{figure}

Die Gefahr, dass ein externer Service, der für ein Smart Home System notwendig ist, offline geht (Discontinued External Servic) ist eine Gefahr die man
als Käufer aktiv eingeht, wenn man sich zum Beispiel ein Cloud-gebundenes Smart Home System kauft. Das Ausmaß der Gefahr lässt sich jedoch
weitesgehend vermeiden, indem man bei etablierten Anbietern einkauft oder einfach komplett auf die Abhängigkeit zu einem externen Service
verzichtet. "Breaking Updates" können Abhängigkeiten im System zerstören und sind somit eine Gefahr, gegen die man als Nutzer nichts unternehmen
kann, außer Updates generell nicht zu installieren. Dadurch muss jedoch auf neue Funktionalitäten verzichtet werden, während sich  gleichzeitig das Risiko erhöht,
dass Sicherheitslücken im System aufkommen. Updates also einfach strikt zu ignorieren ist nicht empfehlenswert, weswegen es, wie bereits in Kapitel
2 erwähnt, einer Möglichkeit bedarf Updates vor ihrer Installation zu überprüfen.[5]

\newpage
\section{Dependency Managment}
Unter Dependency Management versteht man im Allgemeinen das Strukturieren von Abhängigkeiten verschiedener 
Systeme/Programme. Es ist oft so, dass Programme nur in Abhängigkeit von anderen Programmen starten können.
Dies stellt auch kein Problem dar, solange die Abhängigkeiten in ihrer Anzahl überschaubar bleiben. 
Realität ist jedoch, dass Programme meist von mehreren Programmen abhängig sind und diese
Prorgramme wiederum abhängig von anderen Programmen. Bei zu vielen Abhängigkeiten verliert man 
als Entwickler und auch als Nutzer schnell den Überblick. Dieses Wirrwarr an Abhängigkeiten bezeichnet man umgangssprachlich 
als "Dependency Hell", denn sobald man einmal den Überblick verloren hat, wird es äußerst schwierig weitere Änderungen am
System vorzunehmen.

 \subsection{Probleme}
Es folgt eine kleine Zusammenfassung, der am häufigsten auftretenden Formen der "Dependency Hell":
\begin{itemize}
 \item Long Chain of Dependencies: Ein Programm A ist abhängig von einem Programm B. Das Programm B wiederum ist abhängig von einem Programm C.
Möchte man nun Programm  A nutzen benötigt man zusätzlich Programm  B und damit auch Programm C. Solche lange Ketten können Konflikte verursachen.
(Siehe Conflicting Dependencies)
\item Conflicting Dependencies: Sei ein Programm A abhängig von einem Programm B1.1, ein anderes Programm B ist abhängig von  Programm B1.2. Programm B 
kann aber nicht gleichzeitig mit der Version 1.1 und der Version 1.2 installiert sein. Dies bedeutet, Programm A und B können nicht gleichzeitig in einem System laufen.
\item Circular Dependencies: Sei ein Programm A abhängig von einer spezifischen Version von Programm B. Programm B wiederum ist abhängig von einer spezifischen
Version von Programm A. Beide Programme können nun nicht geupdatet werden, da sie die Abhängigkeiten kaputt verletzen würden.
\item Version Lock: Durch einen Version Lock ist man dazu gewungen beim updaten einer Software alle abhängigen Programme ebenfalls upzudaten. (semver.org)
\item Version Promiscuity: Werden Abhängigkeiten zu locker betrachtet können zukünftige Updates als kompatibel angesehen werden, obwohl sie es nicht sind.
\end{itemize}

Für die genannten Probleme existieren bereits viele Ansätze, um gegen sie vorzugehen oder sie zu vermeiden. Dazu gehören:

\subsection{Lösungen}
\begin{itemize}
 \item Semantic Versioning: Semantic Versioning versioniert Software nach dem Format "MAJOR.MINOR.PATCH", um Probleme wie Version Lock 
oder Version Promiscuity zu vermeiden. Dafür benötigt 
man eine Schnittstelle der man die Änderungen an der Software mitteilt. Bei Änderungen, die die API betreffen und nicht abwärtskompatibel
sind muss die MAJOR Nummer erhöht werden. Bei Änderungen, die abwärtskompatibel sind, muss die MINOR Nummer erhöht werden. 
Änderungen, die die API nicht betreffen erhöhen die Patch Nummer. Es gibt noch viele weitere Spezifikationen bezüglich Semantic
Versioning, das grobe Konzept sollte jedoch verstanden sein. 
\item Package Manager: Package Manager sind Tools die sich um das installieren, updaten und konfigurieren von Programmen automatisch
kümmern, wodurch eine manuelle Konfiguration nicht mehr nötig ist. [Wikipedia]
\item Portable Applications: Portable Applikationen umgehen die Probleme, die
Abhängigkeiten mit sich bringen. Sie funktionieren selbstständig,
indem alle nötigen Komponenten bereits vorhanden sind.
\end{itemize}

Die Auflistungen sollen zeigen, dass Dependency Management ein allgegenwärtiges Thema ist, welches in den meisten Bereichen bereits
viel Aufmerksamkeit bekommt. Dependency Management umfasst natürlich noch viele weitere Probleme und dazugehörige Lösungen und Lösungsansätze,
im Bereich Smart Home exisitiert jedoch nahezu keine Forschungsgrundlage. Als Nutzer kann man nur hoffen, dass neue Updates keine Schäden anrichten, 
da es keine Möglichkeit gibt sich davor zu schützen. 


\section{Fazit}

Im Bereich Software Engineering wird Langlebigkeit viel Aufmerksamkeit geschenkt. Smart Home Systeme sind selbstverständlich Teil des
Software Engineerings, aber schaut man sich den aktuellen Stand der Forschung der Langlebigkeit explizit im Bereich der Smart Home
Systeme an, wird deutlich das diesbezüglich kaum Forschungsgrundlagen bestehen.
Dabei werden Smart Home Systeme als Luxusgüter angesehen von denen man aufgrund der hohen Preise eine lange Lebensspanne erwartet.
Um dies zu gewährleisten werden generelle Ansätze des Software Engineerings bezüglich Langlebigkeit genutzt, ausreichend ist dies jedoch nicht.
Ohne vernünftiges Dependency Management kann nicht gewährleistet werden, dass Updates keine Ausfälle in Smart Home Systemen verursachen.
Dies sieht man am Beispiel des Logitech Harmony Hub's. Logitech hatte eine 
neue Firmware Version für das Hub veröffentlicht, welche angeblich nur Sicherheitslücken schließen und Bugs fixen sollte.
Nachdem Update kam es jedoch vermehrt zu Ausfällen zwischen dem Hub und third-party Geräten. Den Nutzern waren die Hände 
gebunden, sie konnten nur darauf hoffen, dass Logitech die Probleme wieder behebt. Dies hat Logitech in diesem Fall auch getan,
dennoch zeigt dieses kleine Beispiel, wie leichtsinnig Updates von Nutzern installiert werden. Eine andere Möglichkeit besitzt man auch als 
Nutzer eines Smart Homes nicht wirklich, da es wie eingangs erwähnt, zur Zeit keine Möglichkeiten gibt Updates vor der Installation zu 
überprüfen.







