\chapter{Related Work}\label{ch:related_work}
In diesem Kapitel wird das Thema Langlebigkeit im Bereich Software Engineering thematisiert. Infolgedessen werden
Smart Home Systeme unter dem Aspekt der Langlebigkeit genauer beleuchtet und  das Thema Dependency Management aufgegriffen, wobei bereits 
bestehende Ansätze/Lösungen diesbezüglich genauer betrachtet werden. Zusätzlich wird der aktuelle Stand des Dependency Managements im 
Bereich Smart Home untersucht.


\section{Smart Homes}
Smart Home Systeme sind grundlegend nichts anderes als die Verknüpfung elektronischer Geräte. Durch die hohe Anzahl 
der Anbieter für Smart Home Systeme existieren jedoch viele Architekturen, die teilweise sehr unterschiedlich funktionieren .
Im Rahmen dieser Arbeit ist es nicht notwendig die verschiedenen Smart Home Architekturen genauer zu beleuchten,
dennoch schadet es nicht sich einen groben Überblick über die aktuellen Technologien zu verschaffen. Grob können die
verschiedenen Architekturen darin unterscheiden werden, ob sie eine Verknüpfung zu einer Cloud besitzen. Cloud gebundene
Architekturen bieten dem Nutzer meist eine einfachere Installation und Wartung, indem zum 
Beispiel Updates automatisch installiert werden. Gleichzeitig bringen sie aber auch potenzielle Gefahren mit sich, da die
Abhängigkeit zu einer Cloud Smart Home Systeme verwundbar machen kann. Wird ein externer Service, wie zum
Beispiel die Cloud abgeschaltet, führt dies bei Cloud-gebundenen Archtiekturen oft zu Ausfällen im System[7].
Des Weiteren sind Geräte, die mit einer Cloud verbunden sind anfälliger gegenüber Angriffen von Außenstehenden, die sich 
Zugriff auf das System beschaffen wollen.
Nicht Cloud-gebundene Architekturen haben diese Nachteile nicht. Es ist jedoch meist schwieriger eine solche Architektur aufzubauen, 
da zum Beispiel, wie im Falle von OpenHab[?] viel manuelle Konfiguration benötigt wird. Zusätzlich bieten nicht Cloud-gebundene Architekturen
mehr Sicherheit, da sie keine starken Abhängigkeiten zu anderen Dienstleistern benötigen.
Natürlich könnte man Smart Home Systeme noch weiter spezifizieren, indem man einzelne Komponenten genauer beleuchet und 
verschiedene Smart Home Anbieter miteinander vergleicht, jedoch ist dies, wie bereits erwähnt, im Rahmen dieser 
Arbeit nicht notwendig. Der zu entwickelnde Algorithmus soll später theoretisch Platform- und Architekturunabhängig anwendbar sein.
Zu diesem Zweck werden im Folgenden einige Aspekte bezüglich Smart Homes definiert und vorausgesetzt. 
Zdankin beschreibt in seiner Arbeit Smart Home Systeme als:

\par
\begingroup
\leftskip=1cm % Parameter anpassen
\noindent %ab hier der Text, der eingerückt werden soll
\textit{"A smart home has a set of devices that are connected through
a platform. Each device has a certain software version and
a set of available updates. Each software version has a set
of available predefined services. Devices can use services of
other devices which creates dependencies. An update configuration
is one of the finite states of the nondeterministic
finite automaton (NFA) that can be constructed by using the
configurations as states and connecting them using individual
updates as transitions." (Zdankin et al., 2020, Requirements and Mechanisms for Smart Home Updates [8])}
\par
\endgroup
Um Missverständnisse zu vermeiden folgen nun zusätzlichen Begriffserklärungen.
Die folgenden Elemente in Abbildung 2.1 sind für ein Smart Home System also essentiell:
\begin{itemize}
\item Device (Gerät): Geräte sind die Komponenten, die die eigentliche Funktionalität anbieten. Sie besitzen eine aktuelle Firmware
Version mit entsprechenden Diensleistungen(Services) und potenzielle Updates. Zusätzlich können sie Abhängigkeiten zu anderen Geräten haben, indem sie auf deren
Dienstleistungen zugreifen.
\item Firmware Version: Die Firmware Version gibt an, auf welcher Version ein Gerät sich befindet und gibt somit an welche Dienstleistungen ein Gerät anbietet.
\item Service (Dienstleistungen): Eine Dienstleistung ist eine Funktionalität, die ein Gerät anbietet. Zum Beispiel bietet ein Thermostat
die Dienstleistung "Temperatur messen" an.
\item Update: Eine Aktualisierung der Firmware eines Geräts. Durch ein Update können sich angebotenen Diensleistungen eines Geräts ändern.
\item Platform: Die Komponente, die alle Geräte miteinander vernetzt.
\item Dependency (Abhängigkeiten): Eine Abhängigkeit zwischen zwei Geräten besteht, wenn ein Gerät Zugriff auf die Dienstleistungen eines
anderen Geräts benötigt.
\end{itemize}

\begin{figure}[!ht]
\hspace*{-2,5cm}                                                           
\includegraphics{"System Model"}
  \caption{Grundlegende Komponenten eines Smart Home Systems}
  \label{fig:Prob1:MEA}
\end{figure}


\newpage
\subsection{Prescriptive vs Descriptive Standards}
Für die Kommunikation der Geräte untereinander existieren viele Kommunikationsprotokolle wie zum Beispiel Bluetooth,
Wi-Fi oder auch XMPP. Diese sind bereits im großen Umfang in Verwendung und stark erforscht, weshalb es keiner weiteren
Untersuchung dieser Protokolle im Rahmend dieser Arbeit bedarf.
Kommunikation allein recht jedoch nicht, die Geräte müssen nicht nur untereinander kommunizieren, sondern sie müssen sich auch 
verstehen. Dafür ist ein Standard notwendig, welcher die Funktionen/Dienstleistungen der Geräte beschreibt.
Die zwei führenden Ansätze im Bereich IoT/Smart Homes sind deskriptive und preskriptive Standards.
Zdankin beschreibt die beiden Standards in seiner Arbeits folgendermaßen:

\textit{
"A standard for service definitions that only regulates how a device can describe itself is
a descriptive standard, because it allows vendors to describe their devices in their own
terms. A recently finalized descriptive standard is the Web Of Things [Ka20; Ko20]. If
devices need to communicate across different descriptive standards, a translation must be
considered. However, McCool et al. have stated security concerns about purely descriptive
approaches, such as scanning for door locks with known physical weaknesses [MR18] (Zdankin et al., 2020, Requirements and Mechanisms for Smart Home Updates [8]).}
\todo{Wie muss ich die Quellenangaben im Zitat zitieren?}

%\footnotetext{[Ka20]: httpsȷ//www.w3.org/TR/wot-thing-description/}
%\footnotetext{[Ko20]: httpsȷ//www.w3.org/TR/wot-architecture/}
%\footnotetext{[MR18]: Mccool, M.; Reshetova, E.ȷ Distributed Security Risks and Opportunities in the
%W3C Web of Things. In. Jan. 2018.}

\textit{
A prescriptive standard does not only regulate the how but also the what of self-description.
These standards prescribe how devices and services should be defined and vendors can use
these terms for unambiguity. By using the same terms to define services, translation is not
required anymore. A prescriptive standard defines all possible devices and all their services
they could implement. However, a device can implement a subset of these services only.
This restriction has benefits as well because it ensures compatibility across device vendors.
Widely used examples are the smart home standards of Amazon, Apple, and Samsung6."
(Zdankin et al., 2020, Requirements and Mechanisms for Smart Home Updates [8])}

In der Realität bieten sich hybride Standards vermutlich am meisten an, da sowohl deskriptive als auch preskriptive Standards Vor- und
Nachteile besitzen.   


\subsection{Update Planing}
Oft werden Smart Home Geräte automatisch über eine aktive Internetverbindung geupdatet oder auch durch andere
Geräte wie zum Beispiel einem Hub. Dies bietet dem Nutzer mehr Komfort, da kein manueller Aufwand für Updates ensteht.
Solches "Remote Updating" sollte aber eigentlich vermieden werden, da dadurch zum Beispiel schädliche Software installiert werden
kann. Außerdem müsste der externe Diensleister, der das Updaten der Geräte übernimmt, viele Informationen über das System sammeln,
um so ideale Updatekonfigurationen zu finden. Das Preisgeben aller Informationen sollte nicht leichtsinnig getan werden, da es viele
potenzielle Gefahren birgt. Allein die Information, wann eine automatisierte Heizung anfängt zu heizen kann potenziellen Kriminellen Informationen
darüber geben, wann jemand zu Hause ist oder wann ein Haus leer steht. 
Idealerweise sollten Nutzer daher das Updaten lokal selbst übernhemen. Dies bedeutet selbstverständlich mehr manuelle Konfiguration,
vor jedem Update, da der Nutzer gefragt werden sollte, ob er ein Update installieren möchte. Diese Frage kann ein Nutzer ohne weitere Informationen
gar nicht plausibel entscheiden. Es wäre also von Vorteil, wenn es für den Nutzer
eine Übersicht über alle möglichen Updates geben würde, in der er sich dann für passende Updates entscheiden kann. 
Für einen solchen Zweck bietet sich Smartphone als zentrales Gerät an um eine Übersicht über alle im 
System vorkommenden Geräte zu erstellen.
Dazu benötigt man eine Möglichkeit die Informationen über die Services und Updates eines Geräts leicht abfragen zu können.
Eine solche Abfrage müsste in der Realität für jedes Gerät individuell angepasst werden. Dies ist jedoch nicht umsetzbar,
weswegen es nötig ist einen einheitlichen Weg zu finden.
Zdankin schlägt vor die Metadaten der Geräte zu diesem Zweck zu nutzen. Geräte besitzen üblicherweise Metadaten, welche Informationen über 
Software Version, Speicherbedarf usw. enthalten. Diesen Metadaten könnte man zusätzlich Informationen über Dienstleistungen und Updates 
hinzufügen, sodass man einen schnellen Überblick über alle Geräte innerhalb eines Netzwerks erhalten kann
(Zdankin et al., 2020, Requirements and Mechanisms for Smart Home Updates [8]). 

\section{Langlebigkeit}
Im Bereich Software Engineering ist Langlebigkeit ein bekanntes Problem. Es wurden bereits Untersuchungen über die durchschnittliche 
Lebensdauer von Software durchgeführt mit dem Ergebnis, dass kleine Projekte im Bereich von unter 100.000 Zeilen Code wird eine Lebensdauer von circa 
6-8 Jahren haben. Dabei ist zu beobachten, dass mit steigender Größe eines Projekts die erwartete Lebensdauer im Durchschnitt
ebenfalls steigt [9]. Dies hängt vermutlich mit den hohen Kosten zusammen, die für größere Projekte aufkommen, weswegen man daran
interessiert ist lange einen Nutzen von der Software zu haben. Gründe für das Altern von Software sind vielseitig. So kann zum Beispiel 
die Wartung von Software einfach zu teuer werden, so dass es sich lohnt neue Software zu entwickeln oder eine Entwicklungsumgebung wird
nicht mehr unterstützt und es lohnt sich nicht die Software zu portieren. Andere Gründe können Sicherheitslücken oder auch fehlerhafte 
Updates sein. Die German Research Foundation hat ein Projekt namens Design for Future ins Leben gerufen, um das Problem der Langlebigkeit
von Software zu untersuchen. Das Projekt beschreibt sein Ziel darin fundamentale neue Ansätze im Bereich langlebiger Software zu finden, um Probleme mit Legacy-Software
oder der Adaption von Software auf neue Plattformen zu lösen und eine kontinuierliche Weiterentwicklung von Software Systemen gewährleisten 
zu können [10].
Im Bereich Smart Home existieren keine solche Programme. Das Problem der Langlebigkeit wird in diesem Kontext unterschätzt oder einfach ignoriert.
Aufgrund der Komplexität der Systeme besitzen sie viele Schwachstellen die zu einem frühzeitigen Ausfall des Systems führen können. Dazu gehören:

\begin{figure}[h]
\centering
\includegraphics{"Threats"}
\caption{Gefahren für die Langlebigkeit von Smart Home Systemen\( ^1\) }
\label{fig:Prob1:MEA}
\end{figure}
\footnote{Zdankin et al, 2020, An Algorithm for Dependency-Preserving Smart Home Updates}

In dieser Arbeit wird hauptsächlich die Gefahr der "Breaking Updates" thematisiert.
"Breaking Updates" können Abhängigkeiten im System zerstören und sind somit Schäden gegen die man als Nutzer nichts unternehmen
kann. Eine Möglichkeit wäre es Updates generell nicht zu installieren, wodurch Nutzer auf neue Funktionalitäten verzichten müssten, während gleichzeitig das Risiko steigt,
dass Sicherheitslücken im System aufkommen. Updates also grundlegend zu ignorieren ist nicht empfehlenswert, weswegen es einer Möglichkeit bedarf
Updates vor ihrer Installation zu überprüfen.
Eine andere Gefahr ist zum Beispiel, dass ein externer Service, der für das Smart Home System notwendig ist, offline gehen kann (Discontinued External Service).[1]
Der Unteschied zu den "Breaking Updates" besteht darin, dass man als Käufer eines Cloud-gebundenen Smart Home Systems diese Gefahr aktiv und willentlich eingeht.
Die ist bei "Breaking Updates" nicht der Fall.
Außerdem lässt sich das Ausmaß der Gefahr eines "discontinued Services" weitesgehend vermeiden, indem man bei etablierten Anbietern einkauft oder
komplett auf die Abhängigkeit zu einem externen Service verzichtet. Auch dies ist bei "Breaking Updates" nicht möglich.


\newpage
\section{Dependency Managment}
Unter Dependency Management versteht man im Allgemeinen das Strukturieren von Abhängigkeiten verschiedener 
Systeme/Programme. Oft können Programme nur in Abhängigkeit von anderen Programmen starten.
Dies stellt kein Problem dar, solange die Abhängigkeiten in ihrer Anzahl überschaubar bleiben. 
Realität ist jedoch, dass Programme meist von mehreren Programmen abhängig sind und diese
Prorgramme wiederum abhängig von anderen Programmen. Bei zu vielen Abhängigkeiten verliert man 
als Entwickler und auch als Nutzer schnell den Überblick. Dieses Wirrwarr an Abhängigkeiten bezeichnet man umgangssprachlich 
als "Dependency Hell", denn sobald man einmal den Überblick verloren hat, wird es äußerst schwierig weitere Änderungen am
System vorzunehmen.

\subsection{Probleme}
Es folgt eine kleine Zusammenfassung, der am häufigsten auftretenden Formen der "Dependency Hell" [11]:
\begin{itemize}
 \item Long Chain of Dependencies: Ein Programm A ist abhängig von einem Programm B. Das Programm B wiederum ist abhängig von einem Programm C.
Möchte man nun Programm  A nutzen benötigt man zusätzlich Programm  B und damit auch Programm C. Solche lange Ketten können Konflikte verursachen.
(Siehe Conflicting Dependencies)
\item Conflicting Dependencies: Sei ein Programm A abhängig von einem Programm B1.1, ein anderes Programm B ist abhängig von  Programm B1.2. Programm B 
kann aber nicht gleichzeitig mit der Version 1.1 und der Version 1.2 installiert sein. Dies bedeutet, Programm A und B können nicht gleichzeitig in einem System laufen.
\item Circular Dependencies: Sei ein Programm A abhängig von einer spezifischen Version von Programm B. Programm B wiederum ist abhängig von einer spezifischen
Version von Programm A. Beide Programme können nun nicht geupdatet werden, da sie die Abhängigkeiten kaputt verletzen würden.
\item Version Lock: Durch einen Version Lock ist man dazu gewungen beim updaten einer Software alle abhängigen Programme ebenfalls upzudaten. (semver.org)
\item Version Promiscuity: Werden Abhängigkeiten zu locker betrachtet können zukünftige Updates als kompatibel angesehen werden, obwohl sie es nicht sind.
\end{itemize}

Für die genannten Probleme existieren bereits viele Ansätze, um gegen sie vorzugehen oder sie zu vermeiden. Dazu gehören [11]:

\subsection{Lösungen}
\begin{itemize}
 \item Semantic Versioning [12]: Semantic Versioning versioniert Software nach dem Format "MAJOR.MINOR.PATCH", um Probleme wie Version Lock 
oder Version Promiscuity zu vermeiden. Dafür benötigt 
man eine Schnittstelle der man die Änderungen an der Software mitteilt. Bei Änderungen, die die API betreffen und nicht abwärtskompatibel
sind muss die MAJOR Nummer erhöht werden. Bei Änderungen, die abwärtskompatibel sind, muss die MINOR Nummer erhöht werden. 
Änderungen, die die API nicht betreffen erhöhen die Patch Nummer. Es gibt noch viele weitere Spezifikationen bezüglich Semantic
Versioning, das grobe Konzept sollte jedoch verstanden sein. 
\item Package Manager: Package Manager sind Tools die sich um das installieren, updaten und konfigurieren von Programmen automatisch
kümmern, wodurch eine manuelle Konfiguration nicht mehr nötig ist.
\item Portable Applications: Portable Applikationen umgehen die Probleme, die
Abhängigkeiten mit sich bringen. Sie funktionieren selbstständig,
indem alle nötigen Komponenten bereits vorhanden sind.
\end{itemize}

Die Auflistungen sollen zeigen, dass Dependency Management ein allgegenwärtiges Thema ist, welches in den meisten Bereichen bereits
viel Aufmerksamkeit bekommt. Dependency Management umfasst natürlich noch viele weitere Probleme und dazugehörige Lösungen und Lösungsansätze,
im Bereich Smart Home exisitiert jedoch nahezu keine Forschungsgrundlage. Als Nutzer kann man nur hoffen, dass neue Updates keine Schäden anrichten, 
da es keine Möglichkeit gibt sich davor zu schützen. 


\section{Fazit}

Im Bereich Software Engineering wird Langlebigkeit viel Aufmerksamkeit geschenkt. Smart Home Systeme sind selbstverständlich Teil des
Software Engineerings, aber schaut man sich den aktuellen Stand der Forschung der Langlebigkeit explizit im Bereich der Smart Home
Systeme an, wird deutlich das diesbezüglich kaum Forschungsgrundlagen bestehen.
Dabei werden Smart Home Systeme als Luxusgüter angesehen von denen man aufgrund der hohen Preise eine lange Lebensspanne erwartet.
Um dies zu gewährleisten werden generelle Ansätze des Software Engineerings bezüglich Langlebigkeit genutzt, ausreichend ist dies jedoch nicht.
Ohne vernünftiges Dependency Management kann nicht gewährleistet werden, dass Updates keine Ausfälle in Smart Home Systemen verursachen.
Dies sieht man am Beispiel des Logitech Harmony Hub's [13]. Logitech hatte eine \todo{umschreiben}
neue Firmware Version für das Hub veröffentlicht, welche Sicherheitslücken schließen und Bugs fixen sollte.
Nachdem Update kam es vermehrt zu Ausfällen zwischen dem Hub und third-party Geräten. Den Nutzern waren die Hände 
gebunden, sie konnten nur darauf hoffen, dass Logitech die Probleme wieder behebt. Dies hat Logitech in diesem Fall auch getan,
dennoch zeigt dieses kleine Beispiel, wie leichtsinnig Updates von Nutzern installiert werden. Eine andere Möglichkeit besitzt man auch als 
Nutzer eines Smart Homes nicht wirklich, da es wie eingangs erwähnt, zur Zeit keine Möglichkeiten gibt Updates vor der Installation zu 
überprüfen.







